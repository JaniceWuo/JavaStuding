### 【狂神说Java】注解和反射

Annotation是从JDK5.0开始引入的新技术

可以通过反射机制编程实现对这些元数据的访问



#### 内置注解

@Override 重写的注解

@Deprecated   废弃的  不推荐使用但是可以使用

@SuppressWarnings 用来抑制编译时的警告信息   需要加一个参数



#### 元注解

作用是负责注解其他的注解。

@Target 表示我们的注解可以用在哪些地方 比如方法上、类上

@Retention 表示该注解什么地方有效  runtime>class>source

@Documented 表示是否将注解生成在文档中

@Inherited  子类可以继承父类中的该注解



#### 自定义注解

使用@interface来声明一个注解

注解的参数写法为：类型+参数名()    比如int age();



#### 反射（Reflection）

java是静态语言，但是反射是java被视为动态语言的关键。

正常方式：引入需要的“包类“名称——>通过new实例化——>取得实例化对象

反射方式：实例化对象——>getClass()方法——>取得完整的"包类"名称

反射对性能有影响，其操作总是慢与直接执行相同的操作。

一个类在内存中只有一个Class对象  一个类被加载后，类的整个结构都会被封装在Class对象中。

##### 获取Class类的实例：

有Person person = new Person()

1.若已知具体的类，通过类的class属性获取  Class c = Person.class

2.已知某个类的实例，调用该实例的getClass()方法获取Class对象 Class c = person.getClass()

3.已知一个类的全类名，通过静态方法forName()获取   Class c = Class.forName("全类名")



##### Java内存分析

堆：存放new的对象和数组

栈：存放基本变量类型   引用对象的变量（会存放这个引用在堆里面的具体地址）

方法区：包含了所有的class和static变量



##### 类的加载与ClassLoader的理解

加载：将class文件字节码内容加载到内存中  并将这些静态数据转换成方法区的运行时的数据结构，然后生成代表这个类的java.lang.Class对象

执行类构造器<clinit>()方法的过程。编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。



##### 什么时候会发生类初始化？

1.类的主动引用（一定会发生类的初始化）

​    new一个类的对象

​    当虚拟机启动，先初始化main方法所在的类

​    使用java.lang.reflect包的方法对类进行反射调用

​    初始化一个类  如果其父类没有被初始化 则会先初始化它的父类 

2.类的被动引用（不会发生类的初始化）

​     当访问一个静态域时，只有真正声明这个域的类才会被初始化。比如：当通过子类引用父类的静态变量，不会导致子类初始化（只会有父类初始化）

​     数组定义类引用，不会触发此类的初始化

​     引用常量不会触发此类的初始化



可以通过构造器创建对象/反射创建对象

```java
newInstance()    invoke
```

##### 性能分析

普通方法最快     关闭检测的反射（.setAccessible(true)）其次        反射方式最慢

##### 通过反射，可以获取注解信息



以上代码均位于`Annotation&Reflection/Annotation`



